# 基于pandas的 数据清洗

# 1. 处理丢失数据
* 有两种丢失数据
    * None
    * np.nan(NaN)
* 两种丢失数据的区别




> 为什么在数据分析中需要用到的是浮点类型的空而不是对象空的?

* 数据分析中常常使用某些形式的运算来处理原始数据，如果原始数据中的空值为NAN的形式，则不会干扰或者中断运算。
* NAN可以参与运算的
* None是不可以参与运算的
* 在pandas中如果遇到了None形式的空值，则pandas会将其强转成NAN的形式

# 2. pandas处理空值操作
* isnull
* notnull
* any
* all
* dropna
* fillna

```python
import numpy as np
import pandas as pd
from pandas import DataFrame,Series
df = DataFrame(data=np.random.randint(0,100,size=(7,5)))
df.iloc[3,4] = None
df.iloc[2,2] = np.nan
df.iloc[5,3] = None

```
## 方式1：对空值进行过滤（删除空所在的行数据）
* 技术：isnull, notnull,any,all
*  any(axis=1):返回True，any作用到的df中的该行中有一个True，False：any作用到的df中该行全部为False
```python
drop_index = df.loc[df.isnull().any(axis=1)].index
df.drop(labels=drop_index,axis=0)
# 使用notnull->> all实现空值的过滤,所以notnull和all的搭配更加简单
df.loc[df.notnull().all(axis=1)]

```
## 方法2 ： dropna:可以直接将确实的行或者列进行删除
```python
df.dropna(axis=0)
```
## 填充赋值
```python
# fillna 对空值进行赋值
df.fillna(value=666) 
# 使用空值的近邻值填充空值 ffill根据前边的进行赋值，bfill根据后边的进行赋值
df.fillna(method='ffill',axis=1)

```
# 3.面试题
* 数据说明：
    * 数据是1个冷库的温度数据，1-7对应7个温度采集设备，1分钟采集一次
* 数据处理目标：
    * 用1-4对应的4个必须设备，通过建立冷酷的温度场关系模型，预估出5-7对应的数据
    * 最后每个冷库中仅需放置4个设备，取代放置7个设备
    * f(1-4)-->y(5-7)
* 数据处理过程：
    * 1. 原始数据中有丢帧的现象，需要作预处理
    * 2. matplotlib绘图
    * 3. 建立逻辑回归模型
* 无标准答案，按个人理解操作即可，请把自己的操作过程以文字形式简单描述以下，谢谢配合。
* 测试数据为testData.xlsx
```python
import pandas as pd
data = pd.read_excel('./testData.xlsx')
data.drop(labels=['none','none1'],axis=1,inplace=True)
data.dropna(axis=0)  # 删除空对应的行数据
data_new = data.fillna(method='ffill',axis=0).fillna(method='bfill',axis=0)
# 检测填充的空值的操作是否实现
data_new.info()
# 检测列中是否存在空值
data_new.isnull().any(axis=0)
```

## 3.1 处理重复数据
```python
# 处理重复数据
df = DataFrame(data=np.random.randint(0,100,size=(7,4)))
df.iloc[1] = [6,6,6,6]
df.iloc[4] = [6,6,6,6]
df.iloc[6] = [6,6,6,6]
df.drop_duplicates(keep=False) # first保持第一个，last是最后一个，False为都不保留,默认为first
```
## 3.2 处理异常数据
```python
# 处理异常数据
# 自定义一个1000行3列（A，B,C)取值范围为0-1的数据源，然后将C列中的值大于其两倍标准差的异常值进行清洗
df = DataFrame(data=np.random.random(size=(1000,3)),columns=['A','B','C'])
print(df)
# 判断异常值的条件：C列中的数据大于C列的两倍标准差，则该数据为异常数据
std_twice = df['C'].std()*2
print(df.loc[~(df['C']> std_twice)])
```